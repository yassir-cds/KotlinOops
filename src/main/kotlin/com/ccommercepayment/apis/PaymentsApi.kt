/**
* Payment Gateway
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: 1.0.0-oas3
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package com.ccommercepayment.apis

import com.ccommercepayment.models.PaymentOperationsRequest
import com.ccommercepayment.models.PaymentOperationsResponse

import com.ccommercepayment.infrastructure.ApiClient
import com.ccommercepayment.infrastructure.ClientException
import com.ccommercepayment.infrastructure.ClientError
import com.ccommercepayment.infrastructure.ServerException
import com.ccommercepayment.infrastructure.ServerError
import com.ccommercepayment.infrastructure.MultiValueMap
import com.ccommercepayment.infrastructure.RequestConfig
import com.ccommercepayment.infrastructure.RequestMethod
import com.ccommercepayment.infrastructure.ResponseType
import com.ccommercepayment.infrastructure.Success
import com.ccommercepayment.infrastructure.toMultiValue

class PaymentsApi(basePath: kotlin.String = "http://localhost") : ApiClient(basePath) {

    /**
    * Gets all payment schedules
    * This operation allows the merchant to retrieve some details about a payment giving an order reference.  When calling this operation, Payment SAAS returns all the schedules associated with the order reference (whatever the order tag) (and so does the amount, the state, the date...), and useful informations for making other operations, such as the captured, remaining, cancelled and refunded amount.
    * @param orderRef The order reference. 
    * @param merchantId The merchant identifier. 
    * @param merchantSiteId The merchant site identifier. 
    * @param authToken Gets or sets the authentication token. 
    * @return PaymentOperationsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1PaymentsAllByOrderRefMerchantsByMerchantIdSitesByMerchantSiteIdGet(orderRef: kotlin.String, merchantId: kotlin.Int, merchantSiteId: kotlin.String, authToken: kotlin.String) : PaymentOperationsResponse {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("authToken" to authToken.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/payments/all/{orderRef}/merchants/{merchantId}/sites/{merchantSiteId}".replace("{"+"orderRef"+"}", "$orderRef").replace("{"+"merchantId"+"}", "$merchantId").replace("{"+"merchantSiteId"+"}", "$merchantSiteId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PaymentOperationsResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentOperationsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> throw ClientException((localVarResponse as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((localVarResponse as ServerError<*>).message ?: "Server error")
        }
    }

    /**
    * Gets payment schedule by tag.
    * This operation allows the merchant to retrieve some details about a payment giving an order reference and an order tag.  When calling this operation, Payment SAAS returns the schedule associated with the order referenceand the specified the order tag (and so does the amount, the state, the date...), and useful informations for making other operations, such as the captured, remaining, cancelled and refunded amount.
    * @param orderRef The order reference. 
    * @param merchantId The merchant identifier. 
    * @param merchantSiteId The merchant site identifier. 
    * @param orderTag The order Tag 
    * @param authToken Gets or sets the authentication token. 
    * @return PaymentOperationsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1PaymentsByOrderRefMerchantsByMerchantIdSitesByMerchantSiteIdByOrderTagGet(orderRef: kotlin.String, merchantId: kotlin.Int, merchantSiteId: kotlin.String, orderTag: kotlin.String, authToken: kotlin.String) : PaymentOperationsResponse {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("authToken" to authToken.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/payments/{orderRef}/merchants/{merchantId}/sites/{merchantSiteId}/{orderTag}".replace("{"+"orderRef"+"}", "$orderRef").replace("{"+"merchantId"+"}", "$merchantId").replace("{"+"merchantSiteId"+"}", "$merchantSiteId").replace("{"+"orderTag"+"}", "$orderTag"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PaymentOperationsResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentOperationsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> throw ClientException((localVarResponse as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((localVarResponse as ServerError<*>).message ?: "Server error")
        }
    }

    /**
    * Gets payment schedule
    * This operation allows the merchant to retrieve some details about a payment giving an order reference.  When calling this operation, Payment SAAS returns the schedule associated with the order reference(and so does the amount, the state, the date...), and useful informations for making other operations, such as the captured, remaining, cancelled and refunded amount.
    * @param orderRef The order reference. 
    * @param merchantId The merchant identifier. 
    * @param merchantSiteId The merchant site identifier. 
    * @param authToken Gets or sets the authentication token. 
    * @return PaymentOperationsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1PaymentsByOrderRefMerchantsByMerchantIdSitesByMerchantSiteIdGet(orderRef: kotlin.String, merchantId: kotlin.Int, merchantSiteId: kotlin.String, authToken: kotlin.String) : PaymentOperationsResponse {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("authToken" to authToken.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/payments/{orderRef}/merchants/{merchantId}/sites/{merchantSiteId}".replace("{"+"orderRef"+"}", "$orderRef").replace("{"+"merchantId"+"}", "$merchantId").replace("{"+"merchantSiteId"+"}", "$merchantSiteId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PaymentOperationsResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentOperationsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> throw ClientException((localVarResponse as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((localVarResponse as ServerError<*>).message ?: "Server error")
        }
    }

    /**
    * Cancel or refund
    * &lt;div id&#x3D;\&quot;doc\&quot;&gt;  &lt;link href&#x3D;\&quot;/redoc/font-awesome-4.7.0/css/font-awesome.min.css\&quot; rel&#x3D;\&quot;stylesheet\&quot; /&gt;  &lt;link href&#x3D;\&quot;/redoc/style.css\&quot; rel&#x3D;\&quot;stylesheet\&quot; /&gt;  &lt;p&gt;This operation allows the merchant to cancel (also refered to as \&quot;void\&quot;) or refund a transaction, according to its current state.&lt;/p&gt;  &lt;p&gt;You can find below the exhaustive list of cases which may happen.&lt;/p&gt;  &lt;div class&#x3D;\&quot;quote info\&quot;&gt;  With a &lt;strong&gt;Cancel&lt;/strong&gt; operation, the customer will not see movement on his bank account, contrary to &lt;strong&gt;Refund&lt;/strong&gt; which gives back the &lt;span&gt;charged &lt;/span&gt;amount.&lt;br /&gt;&lt;br /&gt;  Cancel is &lt;span&gt;only &lt;/span&gt;performed when :  &lt;ul&gt;&lt;li&gt;the transaction is not yet captured (in which case, the fund reservation on the customer payment method is cleared)&lt;/li&gt;&lt;li&gt;the operation occurs the same day as the capture operation.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;  &lt;div class&#x3D;\&quot;quote success\&quot;&gt;  If you want to cancel or refund less than the original transaction amount, you can specify the amount in the request body. Alternatively you can specify an amount of 0 if you want to refund the total amount.  &lt;p&gt;&lt;strong&gt;&lt;u&gt;Partial operation&lt;/u&gt;&lt;/strong&gt; :  &lt;em&gt;  0 &lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;span style&#x3D;\&quot;color: rgb(0, 0, 128);\&quot;&gt;amount &lt;/span&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt; transaction&#39;s amount&lt;br /&gt;&lt;/em&gt;&lt;u&gt;&lt;strong&gt;Full operation&lt;/strong&gt;&lt;/u&gt; :  &lt;em&gt;&lt;em&gt;&lt;span style&#x3D;\&quot;color: rgb(0, 0, 128);\&quot;&gt;  amount  &lt;strong&gt;&lt;span style&#x3D;\&quot;color: rgb(0, 0, 0);\&quot;&gt;&#x3D;&#x3D;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; transaction&#39;s amount &lt;strong&gt;OR&lt;/strong&gt;&lt;span style&#x3D;\&quot;color: rgb(0, 0, 128);\&quot;&gt;amount&lt;/span&gt;&lt;strong&gt;&#x3D;&#x3D;&lt;/strong&gt; 0                      &lt;/em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;  &lt;h3&gt;Cancel Or Refund cases&lt;/h3&gt;  &lt;h4&gt;              After the authorization, and before the capture          &lt;/h4&gt;  &lt;p class&#x3D;\&quot;quote info\&quot;&gt;  &lt;em&gt;  &lt;em&gt;Because the refund operation cannot be executed on a non-captured transaction&lt;/em&gt;, only the cancel operation is supported              &lt;/em&gt;    &lt;/p&gt;  &lt;table class&#x3D;\&quot;relative-table wrapped\&quot; style&#x3D;\&quot;width: 91.7576%;\&quot;&gt;  &lt;colgroup&gt;  &lt;col style&#x3D;\&quot;width: 51.1326%;\&quot; /&gt;  &lt;col style&#x3D;\&quot;width: 48.7893%;\&quot; /&gt;      &lt;/colgroup&gt;  &lt;tbody&gt;  &lt;tr&gt;  &lt;th&gt;  &lt;strong&gt; Partial operation&lt;/strong&gt;          &lt;/th&gt;  &lt;th&gt;  &lt;em&gt;  &lt;strong&gt;Full operation&lt;/strong&gt;            &lt;/em&gt;          &lt;/th&gt;        &lt;/tr&gt;  &lt;tr&gt;  &lt;td&gt;  &lt;p&gt;No interaction with partners because partial cancel/void is not supported.&lt;/p&gt;  &lt;p&gt;The only impact is an update of the remaining amount to capture in payment hub.&lt;/p&gt;          &lt;/td&gt;  &lt;td&gt;  &lt;p&gt;  &lt;strong&gt;Cancel&lt;/strong&gt; operation will be executed on the entire transaction.                          &lt;/p&gt;  &lt;p&gt;The fund reservation on the customer payment method will be cleared, and capture will no longer be possible.&lt;/p&gt;  &lt;p class&#x3D;\&quot;quote warning\&quot;&gt;                              Cancelling a non captured transaction is not worldwide supported. Depending on the payment partner (PSP), the acquiring bank, and the issuing bank.                          &lt;/p&gt;          &lt;/td&gt;        &lt;/tr&gt;      &lt;/tbody&gt;    &lt;/table&gt;  &lt;h4&gt;After the capture&lt;/h4&gt;  &lt;p class&#x3D;\&quot;quote info\&quot;&gt;              Because the balance is made at midnight, either the cancel operation or the refund operation will be selected depending on the date.          &lt;/p&gt;  &lt;table class&#x3D;\&quot;wrapped\&quot;&gt;  &lt;colgroup&gt;  &lt;col /&gt;  &lt;col /&gt;  &lt;col /&gt;      &lt;/colgroup&gt;  &lt;tbody&gt;  &lt;tr&gt;  &lt;th&gt;  &lt;br /&gt;          &lt;/th&gt;  &lt;th&gt;  &lt;em&gt;  &lt;strong&gt;Partial operation&lt;/strong&gt;            &lt;/em&gt;          &lt;/th&gt;  &lt;th&gt;  &lt;em&gt;  &lt;em&gt;  &lt;strong&gt;Full operation&lt;/strong&gt;              &lt;/em&gt;            &lt;/em&gt;          &lt;/th&gt;        &lt;/tr&gt;  &lt;tr&gt;  &lt;td class&#x3D;\&quot;highlight-grey\&quot; data-highlight-colour&#x3D;\&quot;grey\&quot;&gt;  &lt;strong&gt;On the same day as the capture operation&lt;/strong&gt;          &lt;/td&gt;  &lt;td&gt;  &lt;div class&#x3D;\&quot;content-wrapper\&quot;&gt;  &lt;p&gt;The &lt;strong&gt;cancel&lt;/strong&gt; operation will be executed.&lt;/p&gt;  &lt;p class&#x3D;\&quot;quote warning\&quot;&gt;  &lt;span&gt;Partial cancelling of a captured transaction is supported, but doesn&#39;t behave the same depending on the payment partner used.&lt;/span&gt;              &lt;/p&gt;            &lt;/div&gt;          &lt;/td&gt;  &lt;td&gt;  &lt;p&gt;The &lt;strong&gt;cancel&lt;/strong&gt; operation will be executed.&lt;/p&gt;  &lt;p&gt;Full cancel of a captured transaction is fully supported.&lt;/p&gt;          &lt;/td&gt;        &lt;/tr&gt;  &lt;tr&gt;  &lt;td class&#x3D;\&quot;highlight-grey\&quot; data-highlight-colour&#x3D;\&quot;grey\&quot;&gt;  &lt;strong&gt;D+1 and later&lt;/strong&gt;          &lt;/td&gt;  &lt;td&gt;The &lt;strong&gt;refund&lt;/strong&gt; operation will be executed.&lt;br /&gt;&lt;br /&gt;Partial refund is fully supported.&lt;/td&gt;  &lt;td&gt;The &lt;strong&gt;refund&lt;/strong&gt; operation will be executed.&lt;br /&gt;&lt;br /&gt;Full refund is fully supported.&lt;/td&gt;        &lt;/tr&gt;      &lt;/tbody&gt;    &lt;/table&gt;  &lt;/div&gt;
    * @param orderRef The OrderRef. 
    * @param authToken Gets or sets the authentication token. 
    * @param paymentOperationsRequest The payment operation request. Materialized by the Body of the PUT request (optional)
    * @return PaymentOperationsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1PaymentsByOrderRefOperationsCancelOrRefundPut(orderRef: kotlin.String, authToken: kotlin.String, paymentOperationsRequest: PaymentOperationsRequest?) : PaymentOperationsResponse {
        val localVariableBody: kotlin.Any? = paymentOperationsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("authToken" to authToken.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/payments/{orderRef}/operations/cancelOrRefund".replace("{"+"orderRef"+"}", "$orderRef"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PaymentOperationsResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentOperationsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> throw ClientException((localVarResponse as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((localVarResponse as ServerError<*>).message ?: "Server error")
        }
    }

    /**
    * Capture
    * This operation charges the bank account of the customer, following a valid authorization done before. You need to provide a succeeded authorized OrderRef, and the amount you want to charge.  This is well suited for a \&quot;charge at shipping\&quot; scenario: the merchant makes an authorization when the customer place the order, and the bank account is charged when the merchant actually does the shipping.    - If you want to capture the total amount of the authorization, you can either set the amount to 0 in the request, or simply not specify it.    ### Useful reminders:    * You can capture the authorization multiple times, as long as there is some amount remaining. For instance, with an authorization of 100€, you can capture 20€ and then capture 80€ later, within the limited time.    * Please note that the authorization is only valid for a limited amount of time, and that you cannot capture a greater amount than the authorized one.
    * @param orderRef The OrderRef. 
    * @param authToken Gets or sets the authentication token. 
    * @param paymentOperationsRequest The payment operation request. Materialized by the Body of the PUT request (optional)
    * @return PaymentOperationsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1PaymentsByOrderRefOperationsCapturePut(orderRef: kotlin.String, authToken: kotlin.String, paymentOperationsRequest: PaymentOperationsRequest?) : PaymentOperationsResponse {
        val localVariableBody: kotlin.Any? = paymentOperationsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("authToken" to authToken.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/payments/{orderRef}/operations/capture".replace("{"+"orderRef"+"}", "$orderRef"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PaymentOperationsResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentOperationsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> throw ClientException((localVarResponse as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((localVarResponse as ServerError<*>).message ?: "Server error")
        }
    }

    /**
    * Recompute schedule
    * This operation forces the recomputation of the payment schedule, using the default payment schedule rules.
    * @param orderRef The OrderRef. 
    * @param authToken Gets or sets the authentication token. 
    * @param paymentOperationsRequest The payment operation request. Materialized by the Body of the PUT request (optional)
    * @return PaymentOperationsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun v1PaymentsByOrderRefOperationsRecomputePut(orderRef: kotlin.String, authToken: kotlin.String, paymentOperationsRequest: PaymentOperationsRequest?) : PaymentOperationsResponse {
        val localVariableBody: kotlin.Any? = paymentOperationsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("authToken" to authToken.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/payments/{orderRef}/operations/recompute".replace("{"+"orderRef"+"}", "$orderRef"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PaymentOperationsResponse>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentOperationsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> throw ClientException((localVarResponse as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((localVarResponse as ServerError<*>).message ?: "Server error")
        }
    }

}
